variable features 80 allot
: append ( @ # c@ -- ) 2dup c@ + over 2>r c@+ + place drop 2r> c! ;
: -v` ."\\_features:_" features c@+ type cr ;

"help" features append
"help`" find 2drop '`' which@ 6+ c! \ to be deleted by hid'm
: help` \ <name> -- ; display help for <name>, or for "help" by default
  wsparse 0= IF 2drop "help" THEN
  [` 2>r "'ff.help" needed 2r> `] 0; \ dup this line for your own help file(s)
  !"no_help_found_for_this_word"

: within over- -rot - u> 2drop nzTRUE ? zFALSE ;  \ n [ ) -- ; nz?
: max` >` IF` swap` THEN` nip` ;  \ n2 n1 -- max(n2,n1)
: min` <` IF` swap` THEN` nip` ;  \ n2 n1 -- min(n2,n1)

: pick` \ xn..x0 n -- xn..x0 xn
  \ must be preceded by "52(push edx)6Axx(push byte)5A(pop edx)"
  here 4- @ $FE00FFFE& $5A006A52- IF !"is_not_preceded_by_a_constant" ;THEN
  drop -3 allot  here 1+ c@ 1- 0= IF drop ;THEN  \ "52(push edx)"=over` C=1
  0< IF drop swap` nipdup` ;THEN  \ i.e. dup`
  $5C8B, s08 10 << $24+ w, ;  \ 8B5C24xx(mov ebx,[esp+4n])
\ $89%11&sd(mov d,s) 0:eax 1:ecx 2:edx 3:ebx 4:esp 5:ebp 6:esi 7:edi
: rp@` over` $C389, s01 ;  \ 89C3(mov ebx,eax) -> 89D8(mov eax,ebx)
: sp@` over` $E389, s01 ;  \ 89E3(mov ebx,esp) -> 89DC(mov esp,ebx)
\ : rsp!` >C1 $D089DC89, s08 s08 2drop` ;  \ rp sp -- ; for multitasking

constant` ' alias equ` \ shorter, and more usual for assembly programmers

\ --------------------------------------------------------------------
\ ?ior malloc/free lseek ioctl/select

variable ior \ I/O result, error when negative:
: ?ior 0- ior! \ n -- ; displays system error message
  0< IF ior@ negate 1 "strerror" libc_ 1 "puts" libc_ !"system_call_failed" THEN
;

: malloc 1 "malloc" libc_    ; \ # -- @ ; see "man malloc"
: free   1 "free" libc_ drop ; \ @ --

\ syscall values see /usr/include/asm-i386/unistd.h
: lseek  3  19 syscall ; \ wh off fd -- off ; wh=0:SET 1:CUR 2:END
: ioctl  3  54 syscall ; \ int ioctl(int fd, int request, void* arg);
: select 5 142 syscall ; \ timeval* exceptfds* writefds* readfds* n -- ?

variable `fdset  0 , 0 , \ for select, the 2 zeros are a null timeval
: key? stdin
: `fdin? \ fd -- ; returns zFALSE if file-descriptor fd would wait for input
  1 swap << `fdset! \ fd_set READ; select will return 0 or 1 (or 0<)
  `fdset 4+ 0 0 `fdset $20 select dup ?ior 0- drop
;
: `TCGETS  $5401 SKIP \ see termios
: `TCSETSW $5403 THEN eob swap stdin ioctl ?ior ;
: ekey \ -- c ; raw access to keyboard input
  \ not yet perfect: line-discipline-control-chars still interpreted,
  \ more to patch in termios structure...
  `TCGETS eob 12+ dup@ swap &100 over! \ -- n eob+12 ; raw
  `TCSETSW key -rot ! `TCSETSW
;

\ --------------------------------------------------------------------
\ OS shell/command interface

\ Note: literal strings are already zero-terminated.
\ Note: as wsparse considers the NUL character as whitespace, NUL may replace
\ any other whitespace (HT,LF,VT,FF,CR,space) without breaking source code.
: zt  \ @ # -- @ ; append zero-terminator
  over+ 0 swap c! ;

: man` >in@ 4- lnparse + over- \ <mantopic> -- ; 4-:"man_" fallthru
: shell  \ @ # -- ; send command to shell, command result into ior
  zt 1 "system" libc_ 0; ior! !"shell_call_failed"
: cd`    \ <newdir> -- ; change directory
  wsparse zt 1 12 syscall ?ior
;
: !!`    \ <line> -- ; send command line to shell
  lnparse shell ;
